[[SQL-Batch]]
=== Batch

image:../images/edit.png[link="https://github.com/ArcadeData/arcadedb-docs/blob/main/src/main/asciidoc/sql/SQL-Batch.adoc" float=right]

ArcadeDB allows execution of arbitrary scripts written in Javascript or any scripting language installed in the JVM. ArcadeDB supports a minimal SQL engine to allow a batch of commands.

Batch of commands are very useful when you have to execute multiple things at the server side avoiding the network roundtrip for each command.

SQL Batch supports all the ArcadeDB <<SQL-Commands,SQL Commands>>, plus the following:

* `begin [isolation &lt;isolation-level&gt;]`, where `&lt;isolation-level&gt;` can be `READ_COMMITTED`, `REPEATABLE_READ`. By default is `READ_COMMITTED`
* `commit [retry &lt;retry&gt;]`, where:
** `&lt;retry&gt;` is the number of retries in case of concurrent modification exception
* `let &lt;variable&gt; = &lt;SQL&gt;`, to assign the result of a SQL command to a variable. To reuse the variable prefix it with the dollar sign `$`.
* `IF(&lt;condition&gt;){ &lt;statememt&gt;; [&lt;statement&gt;;]* }`. Look at <<Conditional-Execution,conditional execution>>.
* `WHILE(&lt;condition&gt;){ &lt;statememt&gt;; [&lt;statement&gt;;]* }`. Look at <<Loops,loop>>.
* `FOREACH(&lt;variable&gt; IN &lt;expression&gt;){ &lt;statememt&gt;; [&lt;statement&gt;;]* }`. Look at <<Loops,loops>>.
* `SLEEP &lt;ms&gt;`, put the batch in wait for `&lt;ms&gt;` milliseconds.
////
* `console.log &lt;text&gt;`, logs a message in the console. Context variables can be used with `${&lt;variable&gt;}`.
* `console.error &lt;text&gt;`, writes a message in the console's standard output. Context variables can be used with `${&lt;variable&gt;}`.
* `console.output &lt;text&gt;`, writes a message in the console's standard error. Context variables can be used with `${&lt;variable&gt;}`.
////
* `return <value>`, where `value` can be:
** any value. Example: `return 3`
** any variable with `$` as prefix. Example: `return $a`
** arrays (HTTP protocol only, see below). Example: `return [ $a, $b ]`
** maps (HTTP protocol only, see below). Example: `return { &#39;first&#39; : $a, &#39;second&#39; : $b }`
** a query. Example: `return (SELECT FROM Foo)`

NOTE: to return arrays and maps (eg. Java or Node.js driver) it's strongly recommended using a RETURN SELECT, eg. 

----
return (SELECT $a as first, $b as second)
----

This will work on any protocol and driver.

*Optimistic transaction*

Example to create a new vertex in a <<Transactions,Transactions>> and attach it to an existent vertex by creating a new edge between them. If a concurrent modification occurs, repeat the transaction up to 100 times:

[source,sql]
----
begin;
let account = create vertex Account set name = 'Luke';
let city = select from City where name = 'London';
let e = create edge Lives from $account to $city;
commit retry 100;
return $e;
----

Note the usage of `$account` and `$city` in further SQL commands.

*Pessimistic transaction*

This script above used an Optimistic approach: in case of conflict it retries up top 100 times by re-executing the entire transaction (commit retry 100). To follow a Pessimistic approach by locking the records, try this:

[source,sql]
----
BEGIN;
let account = CREATE VERTEX Account SET name = 'Luke';
let city = SELECT FROM City WHERE name = 'London';
let e = CREATE EDGE Lives FROM $account TO $city;
COMMIT;
return $e;
----

[[Conditional-Execution]]
*Conditional execution*
SQL Batch provides IF constructor to allow conditional execution.
The syntax is

[source,sql]
----
if(<sql-predicate>){
   <statement>;
   <statement>;
   ...
}
----

`&lt;sql-predicate&gt;` is any valid SQL predicate (any condition that can be used in a `WHERE` clause).
In current release it's mandatory to have `IF(){`, `&lt;statement&gt;` and `}` on separate lines, eg. the following is not a valid script

[source,sql]
----
if($a.size() > 0) {
  ROLLBACK;
}
----

The right syntax is following:

[source,sql]
----
if($a.size() > 0) { 
   ROLLBACK;
}
----

[[Loops]]
*Loops*

SQL Batch provides two different loop blocks: `FOREACH` and `WHILE`

[discrete]

==== FOREACH

Loops on all the items of a collection and, for each of them, executes a set of SQL statements

The syntax is

[source,sql]
----
FOREACH(<variable> IN <expression>){
   <statement>;
   <statement>;
   ...
}
----

Example

[source,sql]
----
FOREACH ($i IN [1, 2, 3]){
  INSERT INTO Foo SET value = $i;
}
----

[discrete]

==== WHILE

Loops while a condition is true

The syntax is

[source,sql]
----
WHILE(<condition>){
   <statement>;
   <statement>;
   ...
}
----

Example

[source,sql]
----
LET $i = 0;
WHILE ($i < 10){
  INSERT INTO Foo SET value = $i;
  LET $i = $i + 1;
}
----
