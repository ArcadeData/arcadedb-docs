[[java-vectors]]
==== Using Vector Embeddings from Java API

Using the Embedded Java API is the fastest way to insert vector embeddings into the database. At the beginning it's much faster to pass through the `HnswVectorIndexRAM` implementation and then generate the persistent index after loaded.

Schema types are created automatically, but you could create them in advance if you want special settings, like a specific number of buckets, or a custom page size.

Example of inserting embeddings in RAM first, and then create the persistent HNSW index.

[source,java]
----
if (!database.getSchema().existsIndex(indexName)) {
  // FIRST TIME: USE OPTIMIZED RAM BASED HNSW INDEX AS FIRST STEP
  final HnswVectorIndexRAM<Object, float[], Item<Object, float[]>, Float> hnswIndex = HnswVectorIndexRAM.newBuilder(
          embeddingService.getDimensions(), distanceFunction, 100_000).withM(m).withEf(ef).withEfConstruction(efConstruction)
      .build();

  hnswIndex.addAll((Collection<Item<Object, float[]>>) embeddings, Runtime.getRuntime().availableProcessors(), null;

  // CREATE UNIQUE TYPE ASSOCIATED TO THE LIBRARY
  final String statementTypeName = getStatementTypeName(vertexLibrary);

  hnswIndex.createPersistentIndex(database)//
      .withVertexType(STATEMENT_TYPE_NAME).withEdgeType(PROXIMITY_TYPE_NAME)//
      .withVectorProperty(VECTOR_PROPERTY_NAME, Type.ARRAY_OF_FLOATS)//
      .withIdProperty(TEXT_PROPERTY_NAME)//
      .withDeletedProperty(DELETED_PROPERTY_NAME)//
      .create();
}
----

Once the persistent index is created, you can just add new entries into the HNSW index:

[source,java]
----
if (database.getSchema().existsIndex(indexName)) {
  final HnswVectorIndex index = (HnswVectorIndex) database.getSchema().getIndexByName(indexName);

  index.addAll(embeddings, (statement, item, total) -> {
    // YOUR CALLBACK TO MANAGE CASCADING OPERATIONS WHEN VERTICES ARE CREATED AND INDEXED, IF ANY
  });
}
----

The callback in the `addAll()` method is useful when you have a graph/tree connected to the vertices created by the index. For example, if you are indexing a book, probably you calculate a vector of embeddings per statement, and then you group the statements in paragraphs.

===== Creating LSMVectorIndex

LSMVectorIndex provides an alternative persistent vector indexing approach based on ArcadeDB's LSM Tree architecture. You can create an LSMVectorIndex using the Java API with the following configuration:

[source,java]
----
// Create or get schema
final Schema schema = database.getSchema();
if (!schema.existsType("Document")) {
  schema.createVertexType("Document");
}

// Create vector property
if (!schema.existsProperty("Document", "embedding")) {
  schema.createProperty("Document", "embedding", Type.ARRAY_OF_FLOATS);
}

// Create LSMVectorIndex
final LSMVectorIndexBuilder builder = new LSMVectorIndexBuilder(database, "Document", new String[]{"embedding"})
    .withDimensions(768)                           // Vector dimensions
    .withSimilarity(VectorSimilarityFunction.COSINE)  // Similarity metric (COSINE, DOT_PRODUCT, EUCLIDEAN)
    .withMaxConnections(16)                        // Max connections per node (default: 16)
    .withBeamWidth(100)                            // Beam width for search (default: 100)
    .withIdProperty("id");                         // ID property name (default: "id")

final LSMVectorIndex index = builder.create();
----

Once the LSMVectorIndex is created, you can add vectors:

[source,java]
----
final LSMVectorIndex index = (LSMVectorIndex) database.getSchema().getIndexByName("Document[embedding]");

// Add vectors to the index
index.addAll(vectors, (vertex, item, total) -> {
  // Callback for handling vertex creation if needed
});
----

You can also configure the index from metadata JSON:

[source,java]
----
final JSONObject metadata = new JSONObject()
    .put("dimensions", 768)
    .put("similarity", "COSINE")
    .put("maxConnections", 16)
    .put("beamWidth", 100)
    .put("idPropertyName", "id");

final LSMVectorIndexBuilder builder = new LSMVectorIndexBuilder(database, "Document", new String[]{"embedding"})
    .fromMetadata(metadata);

final LSMVectorIndex index = builder.create();
----
