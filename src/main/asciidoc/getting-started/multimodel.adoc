[[multi-model]]
=== Multi Model

image:../images/edit.png[link="https://github.com/ArcadeData/arcadedb-docs/blob/main/src/main/asciidoc/getting-started/multimodel.adoc" float="right"]

The ArcadeDB engine supports **Graph**, **Document**, **Key/Value**, **Search-Engine**, **Time-Series**, and **Vector-Embedding** models, so you can use ArcadeDB as a replacement for a product in any of these categories. However, the main reason why users choose ArcadeDB is because of its true **Multi-Model** DBMS ability, which combines all the features of the above models into one core. This is not just interfaces to the database engine, but rather the engine itself was built to support all models. This is also the main difference to other multi-model DBMSs, as they implement an additional layer with an API, which mimics additional models. However, under the hood, they're truly only one model, therefore they are limited in speed and scalability.

image::https://arcadedb.com/assets/images/multi-model-small.png[align="center"]

[[graph-model]]
==== Graph Model

A graph represents a network-like structure consisting of Vertices (also known as Nodes) interconnected by Edges (also known as Arcs). ArcadeDB's graph model is represented by the concept of a property graph, which defines the following:

* **Vertex** - an entity that can be linked with other vertices and has the following mandatory properties:
** unique identifier
** set of incoming edges
** set of outgoing edges
** label that defines the type of vertex

* **Edge** - an entity that links two vertices and has the following mandatory properties:
** unique identifier
** link to an incoming vertex (also known as head)
** link to an outgoing vertex (also known as tail)
** label that defines the type of connection/relationship between head and tail vertex

In addition to mandatory properties, each vertex or edge can also hold a set of custom properties. These properties can be defined by users, which can make vertices and edges appear similar to documents.
Furthermore, edges are sorted by the reverse order of insertion,
meaning the last edge added is the first when listed, cf. "Last In First Out".

In the table below, you can find a comparison between the graph model, the relational data model, and the ArcadeDB graph model:

[%header,cols=3]
|===
| Relational Model | Graph Model              | ArcadeDB Graph Model
| Table            | Vertex and Edge Types    | Type
| Row              | Vertex                   | Vertex
| Column           | Vertex and Edge property | Vertex and Edge property
| Relationship     | Edge                     | Edge
|===


[[document-model]]
==== Document Model

The data in this model is stored inside documents. A document is a set of key/value pairs (also referred to as fields or properties), where the key allows access to its value. Values can hold primitive data types, embedded documents, or arrays of other values. Documents are not typically forced to have a schema, which can be advantageous, because they remain flexible and easy to modify. Documents are stored in collections, enabling developers to group data as they decide. ArcadeDB uses the concepts of "<<types,Types>>" and "<<buckets,Buckets>>" as its form of "collections" for grouping documents. This provides several benefits, which we will discuss in further sections of the documentation.

ArcadeDB's document model also adds the concept of a "<<relationships,Relationship>>" between documents. With ArcadeDB, you can decide whether to embed documents or link to them directly. When you fetch a document, all the links are automatically resolved by ArcadeDB. This is a major difference to other document databases, like MongoDB or CouchDB, where the developer must handle any and all relationships between the documents themself.

The table below illustrates the comparison between the relational model, the document model, and the ArcadeDB document model:

[%header,cols=3]
|===
| Relational Model | Document Model   | ArcadeDB Document Model
| Table            | Collection       | <<types,Type>> or <<buckets,Bucket>>
| Row              | Document         | Document
| Column           | Key/value pair   | Document property
| Relationship     | not available    | <<relationships,Relationship>>
|===


[[keyvalue-model]]
==== Key/Value Model

This is the simplest model. Everything in the database can be reached by a key, where the values can be simple and complex types. ArcadeDB supports documents and graph elements as values allowing for a richer model, than what you would normally find in the typical key/value model. The usual Key/Value model provides "buckets" to group key/value pairs in different containers. The most typical use cases of the Key/Value Model are:

- POST the value as payload of the HTTP call -> `/<bucket>/<key>`
- GET the value as payload from the HTTP call -> `/<bucket>/<key>`
- DELETE the value by Key, by calling the HTTP call -> `/<bucket>/<key>`

The table below illustrates the comparison between the relational model, the Key/Value model, and the ArcadeDB Key/Value model:

[%header,cols=3]
|===
| Relational Model | Key/Value Model   | ArcadeDB Key/Value Model
| Table            | Bucket           | <<buckets,Bucket>>
| Row              | Key/Value pair   | Document
| Column           | not available    | Document field or Vertex/Edge property
| Relationship     | not available    | <<relationships,Relationship>>
|===


[[searchengine-model]]
==== Search-Engine Model

The search engine model is based on a full-text variant of the <<indexes,LSM-Tree index>>.
To index each word, the necessary tokenization is performed by the https://lucene.apache.org[Apache Lucene] library.
Such a full-text index is <<sql-create-index,created just like any index>> in ArcadeDB.


[[timeseries-model]]
==== Time-Series Model

ArcadeDB includes a native Time Series engine designed for high-throughput ingestion and fast analytical queries over timestamped data.
The Time Series model is integrated directly into the multi-model core -- the same database that stores graphs, documents, and key/value pairs can store and query billions of time-stamped samples with specialized columnar compression, SIMD-vectorized aggregation, and automatic lifecycle management.

Key capabilities:

- **Columnar storage** with Gorilla, Delta-of-Delta, Simple-8b, and Dictionary compression -- as low as 0.4 bytes per sample
- **Shard-per-core parallelism** with lock-free writes
- **InfluxDB Line Protocol** ingestion for compatibility with Telegraf, Grafana Agent, and hundreds of collection agents
- **Prometheus remote_write / remote_read** protocol for drop-in Prometheus backend usage
- **PromQL query language** with native parser and HTTP-compatible API endpoints
- **SQL analytical functions** -- `ts.timeBucket`, `ts.rate`, `ts.percentile`, `ts.interpolate`, and more
- **Continuous aggregates**, **retention policies**, and **downsampling tiers** for automatic data lifecycle
- **Grafana integration** via DataFrame-compatible endpoints
- **Studio TimeSeries Explorer** with query, schema inspection, ingestion docs, and PromQL tabs

For the full reference, including DDL syntax, ingestion methods, SQL functions, PromQL support, and Grafana integration, see <<timeseries,Time Series>>.


[[vector-model]]
==== Vector Model

ArcadeDB provides a high-performance vector indexing solution using the LSMVectorIndex, which is built on the https://github.com/jelmerk/jvector[JVector 4.0.0 library]. This implements the https://arxiv.org/abs/1603.09320[hierarchical navigable small world] (HNSW) algorithm for efficient approximate nearest neighbor (ANN) search on multi-dimensional vector data.

The LSMVectorIndex combines the HNSW algorithm with ArcadeDB's LSM Tree architecture, providing:

- **Persistent Storage**: Vector indexes are stored on disk with automatic page management and compaction
- **Transaction Support**: Full ACID compliance with automatic persistence on transaction commit
- **Multiple Similarity Functions**: Supports COSINE (default), DOT_PRODUCT, EUCLIDEAN, and others
- **SQL Integration**: Create and query vector indexes using SQL commands
- **Automatic Compaction**: Efficiently reclaims disk space through automatic compaction of immutable pages
- **High Performance**: LSM Tree benefits for write efficiency and space optimization at scale

===== SQL Example

Create a vector index and query it:

```sql
-- Create vertex type and property
CREATE VERTEX TYPE Document;
CREATE PROPERTY Document.content STRING;
CREATE PROPERTY Document.embedding ARRAY OF FLOATS;

-- Create vector index with 384 dimensions using COSINE similarity
CREATE INDEX ON Document (embedding) LSM_VECTOR METADATA {
  dimensions: 384,
  similarity: 'COSINE'
};

-- Query for similar documents
SELECT content FROM Document
WHERE vectorNeighbors('embedding', $queryVector, 10) > 0.8
ORDER BY vectorNeighbors('embedding', $queryVector, 10) DESC
LIMIT 5;
```

===== Java Example

Create and query a vector index programmatically:

```java
import com.arcadedb.index.lsm.LSMVectorIndex;
import com.arcadedb.index.lsm.LSMVectorIndexBuilder;
import com.arcadedb.index.vector.VectorSimilarityFunction;

// Create index programmatically
final LSMVectorIndexBuilder builder = new LSMVectorIndexBuilder(
    database,
    "Document",
    new String[]{"embedding"})
    .withDimensions(384)
    .withSimilarity(VectorSimilarityFunction.COSINE)
    .withMaxConnections(16)
    .withBeamWidth(100);

final LSMVectorIndex index = builder.create();

// Query the index using SQL
final ResultSet resultSet = database.query("sql",
    "SELECT FROM Document " +
    "WHERE vectorNeighbors('embedding', ?, 10) > 0.8 " +
    "LIMIT 5",
    queryVector);
```

[[additional-settings]]
===== Configuration Parameters

When creating LSMVectorIndex instances, the following parameters can be configured:

- `dimensions`: The dimensionality of the vectors (must match your embedding model output)
- `similarity`: The distance function for similarity calculation (COSINE, DOT_PRODUCT, EUCLIDEAN, etc.)
- `maxConnections`: Maximum number of connections per layer in the HNSW graph (default: 16, increase for better recall)
- `beamWidth`: Beam width for approximate nearest neighbor search (default: 100, increase for more accurate results)

[[similarity]]
===== Supported Similarity Functions

[%header,cols=3]
|===
| Measure | Name | Type
| `COSINE` | https://en.wikipedia.org/wiki/Cosine_similarity[Cosine Similarity] | L~2~
| `DOT_PRODUCT` | https://en.wikipedia.org/wiki/Dot_product[Inner Product] | L~2~
| `EUCLIDEAN` | https://en.wikipedia.org/wiki/Euclidean_distance[Euclidean Distance] | L~2~
|===

For more information on vector embeddings, see the <<java-vectors,Vector Embeddings>> section.
