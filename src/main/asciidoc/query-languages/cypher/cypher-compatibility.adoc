[[cypher-compatibility]]
=== Cypher Compatibility Matrix
image:../images/edit.png[link="https://github.com/ArcadeData/arcadedb-docs/blob/main/src/main/asciidoc/query-languages/cypher/cypher-compatibility.adoc" float=right]

This section provides a comprehensive overview of Cypher language features and their support status in ArcadeDB's native OpenCypher implementation.

[discrete]
==== Overall Status

[%header,cols="3,1,4"]
|===
| Category | Status | Notes
| Parser | 100% | ANTLR4-based using official Cypher 2.5 grammar
| Basic Read Queries | 95% | MATCH, WHERE, RETURN, ORDER BY, SKIP, LIMIT
| Basic Write Queries | 100% | CREATE, SET, DELETE, MERGE with automatic transactions
| Expression Evaluation | 100% | Complete: arithmetic, maps, lists, comprehensions, projections
| Functions | 100% | 23 Cypher functions + bridge to 100+ SQL functions
| Aggregations & Grouping | 100% | Implicit GROUP BY, all aggregation functions
| Advanced Features | 80% | Named paths, OPTIONAL MATCH, WITH, UNION, CALL, PROFILE
|===

**Legend:** ✅ Supported | ❌ Not Supported | ⚠️ Partial Support

[discrete]
==== Clauses

[%header,cols="2,1,3"]
|===
| Clause | Status | Notes
| MATCH | ✅ | Single/multiple patterns, labels, properties
| MATCH (comma-separated) | ✅ | Cartesian product support
| MATCH (multiple clauses) | ✅ | Chained matching
| OPTIONAL MATCH | ✅ | LEFT OUTER JOIN semantics
| WHERE | ✅ | All comparison and logical operators
| RETURN | ✅ | Variables, properties, aliases, expressions
| RETURN DISTINCT | ❌ | Not yet implemented
| ORDER BY | ✅ | ASC/DESC, multiple fields
| SKIP | ✅ | Pagination support
| LIMIT | ✅ | Result limiting
| CREATE | ✅ | Vertices, edges, properties
| SET | ✅ | Property updates
| DELETE | ✅ | Vertices and edges
| DETACH DELETE | ✅ | Delete with relationships
| MERGE | ✅ | Find or create patterns
| ON CREATE SET | ✅ | Execute on new elements
| ON MATCH SET | ✅ | Execute on existing elements
| WITH | ✅ | Query chaining, projection, aggregation
| UNWIND | ✅ | List expansion
| UNION | ✅ | Combine results with deduplication
| UNION ALL | ✅ | Combine results keeping duplicates
| CALL | ✅ | Built-in procedures + custom functions
| FOREACH | ❌ | Not implemented
| EXPLAIN | ✅ | Query plan visualization
| PROFILE | ✅ | Execute with profiling metrics
|===

[discrete]
==== Pattern Matching

[%header,cols="3,1,3"]
|===
| Feature | Status | Example
| Node patterns | ✅ | `(n:Person)`
| Node with properties | ✅ | `(n:Person {name: 'Alice'})`
| Relationship patterns | ✅ | `(a)-[r:KNOWS]->(b)`
| Relationship with properties | ✅ | `(a)-[r:WORKS_AT {since: 2020}]->(b)`
| Bidirectional relationships | ✅ | `(a)-[r]-(b)`
| Variable-length paths | ✅ | `(a)-[*1..3]->(b)`
| Named paths | ✅ | `p = (a)-[:KNOWS]->(b)`
| Multiple relationship types | ✅ | `(a)-[:KNOWS\|LIKES]->(b)`
| Patterns without labels | ✅ | `(n) WHERE n.age > 25`
|===

[discrete]
==== WHERE Operators

[%header,cols="3,1,3"]
|===
| Operator | Status | Example
| Equals (=) | ✅ | `WHERE n.name = 'Alice'`
| Not equals (<>, !=) | ✅ | `WHERE n.age <> 30`
| Less than (<) | ✅ | `WHERE n.age < 40`
| Greater than (>) | ✅ | `WHERE n.age > 25`
| Less or equal (<=) | ✅ | `WHERE n.age <= 40`
| Greater or equal (>=) | ✅ | `WHERE n.age >= 25`
| AND | ✅ | `WHERE n.age > 25 AND n.city = 'NYC'`
| OR | ✅ | `WHERE n.age < 20 OR n.age > 60`
| NOT | ✅ | `WHERE NOT n.retired = true`
| IS NULL | ✅ | `WHERE n.email IS NULL`
| IS NOT NULL | ✅ | `WHERE n.phone IS NOT NULL`
| IN | ✅ | `WHERE n.name IN ['Alice', 'Bob']`
| STARTS WITH | ✅ | `WHERE n.name STARTS WITH 'A'`
| ENDS WITH | ✅ | `WHERE n.email ENDS WITH '@example.com'`
| CONTAINS | ✅ | `WHERE n.name CONTAINS 'li'`
| Regular expression (=~) | ✅ | `WHERE n.name =~ 'A.*'`
| Pattern predicates | ✅ | `WHERE (n)-[:KNOWS]->()`
| Parenthesized expressions | ✅ | `WHERE (n.age < 26 OR n.age > 35) AND n.email IS NOT NULL`
| EXISTS subquery | ⚠️ | Basic syntax supported, variable scoping limited
|===

[discrete]
==== Aggregation Functions

[%header,cols="2,1,3"]
|===
| Function | Status | Notes
| count(expr) | ✅ | Count non-null values
| count(*) | ✅ | Count all rows
| sum(expr) | ✅ | Sum numeric values
| avg(expr) | ✅ | Average numeric values
| min(expr) | ✅ | Minimum value
| max(expr) | ✅ | Maximum value
| collect(expr) | ✅ | Collect values into list
| percentileCont() | ⚠️ | Available via SQL bridge
| stDev() | ⚠️ | Available via SQL bridge
|===

NOTE: Implicit GROUP BY is fully supported. Non-aggregated expressions in RETURN automatically become grouping keys.

[discrete]
==== String Functions

[%header,cols="2,1,3"]
|===
| Function | Status | Example
| toUpper(str) | ✅ | `RETURN toUpper(n.name)`
| toLower(str) | ✅ | `RETURN toLower(n.name)`
| trim(str) | ✅ | `RETURN trim(n.name)`
| substring(str, start, len) | ✅ | `RETURN substring(n.name, 0, 3)`
| replace(str, from, to) | ✅ | `RETURN replace(n.name, 'a', 'A')`
| split(str, delimiter) | ✅ | `RETURN split(n.name, ' ')`
| left(str, len) | ✅ | `RETURN left(n.name, 3)`
| right(str, len) | ✅ | `RETURN right(n.name, 3)`
| reverse(str) | ✅ | `RETURN reverse(n.name)`
| toString(value) | ✅ | `RETURN toString(n.age)`
|===

[discrete]
==== Math Functions

[%header,cols="2,1,3"]
|===
| Function | Status | Example
| abs(num) | ✅ | `RETURN abs(n.value)`
| ceil(num) | ✅ | `RETURN ceil(n.value)`
| floor(num) | ✅ | `RETURN floor(n.value)`
| round(num) | ✅ | `RETURN round(n.value)`
| sqrt(num) | ✅ | `RETURN sqrt(n.value)`
| rand() | ✅ | `RETURN rand()`
|===

[discrete]
==== List Functions

[%header,cols="2,1,3"]
|===
| Function | Status | Example
| size(list) | ✅ | `RETURN size([1,2,3])`
| head(list) | ✅ | `RETURN head([1,2,3])` (returns 1)
| tail(list) | ✅ | `RETURN tail([1,2,3])` (returns [2,3])
| last(list) | ✅ | `RETURN last([1,2,3])` (returns 3)
| range(start, end) | ✅ | `RETURN range(1, 10)`
| reverse(list) | ✅ | `RETURN reverse([1,2,3])`
|===

[discrete]
==== Node/Relationship Functions

[%header,cols="2,1,3"]
|===
| Function | Status | Example
| id(node) | ✅ | `RETURN id(n)` (returns RID as string)
| labels(node) | ✅ | `RETURN labels(n)`
| type(rel) | ✅ | `RETURN type(r)`
| keys(node) | ✅ | `RETURN keys(n)`
| properties(node) | ✅ | `RETURN properties(n)`
| startNode(rel) | ✅ | `RETURN startNode(r)`
| endNode(rel) | ✅ | `RETURN endNode(r)`
|===

[discrete]
==== Path Functions

[%header,cols="2,1,3"]
|===
| Function | Status | Notes
| length(path) | ✅ | Path length in relationships
| nodes(path) | ✅ | Extract nodes from path
| relationships(path) | ✅ | Extract relationships from path
| shortestPath() | ⚠️ | Available via SQL bridge
| allShortestPaths() | ⚠️ | Available via SQL bridge
|===

[discrete]
==== Type Conversion Functions

[%header,cols="2,1,3"]
|===
| Function | Status | Example
| toString(value) | ✅ | `RETURN toString(123)`
| toInteger(value) | ✅ | `RETURN toInteger('42')`
| toFloat(value) | ✅ | `RETURN toFloat('3.14')`
| toBoolean(value) | ✅ | `RETURN toBoolean(1)`
|===

[discrete]
==== Expression Features

[%header,cols="3,1,3"]
|===
| Feature | Status | Example
| List literals | ✅ | `RETURN [1, 2, 3]`
| CASE expressions | ✅ | `CASE WHEN n.age < 18 THEN 'minor' ELSE 'adult' END`
| Type coercion | ✅ | `toInteger('42')`
| Map literals | ✅ | `RETURN {name: 'Alice', age: 30}`
| List comprehensions | ✅ | `[x IN list WHERE x > 2 \| x * 10]`
| Map projections | ✅ | `RETURN n{.name, .age}`, `n{.*}`
| Arithmetic expressions | ✅ | `RETURN n.age * 2 + 10`
|===

[discrete]
==== Not Implemented Features

The following Cypher features are not currently implemented:

* **FOREACH**: Iterating over lists in write operations
* **Subqueries**: Nested queries beyond EXISTS
* **DISTINCT in RETURN**: `RETURN DISTINCT n.name`
* **Index hints**: `USING INDEX n:Person(name)`

[discrete]
==== Known Limitations

1. **Variable-length path duplicates**: Variable-length traversals (`-[*1..3]->`) may return duplicate results. Use `LIMIT` or deduplicate in application logic.

2. **EXISTS variable scoping**: The EXISTS subquery does not have access to variables from the outer query scope.

